/* stfe.h -- generated by Trunnel v1.5.3.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#ifndef TRUNNEL_STFE_H
#define TRUNNEL_STFE_H

#include <stdint.h>
#include "trunnel.h"

#define MAGIC_V1 6004501466958485041
#define T_GET_ENTRIES_V1 1
#define T_GET_PROOF_BY_HASH_V1 2
#define T_GET_CONSISTENCY_PROOF_V1 3
#define T_ENTRIES_V1 4
#define T_INCLUSION_PROOF_V1 5
#define T_CONSISTENCY_PROOF_V1 6
#define T_SIGNED_TREE_HEAD_V1 7
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_HASH)
struct hash_st {
  uint8_t hash[32];
  uint8_t trunnel_error_code_;
};
#endif
typedef struct hash_st hash_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_REQ_GET_CONSISTENCY_PROOF_V1)
struct req_get_consistency_proof_v1_st {
  uint64_t old_size;
  uint64_t new_size;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct req_get_consistency_proof_v1_st req_get_consistency_proof_v1_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_REQ_GET_ENTRIES_V1)
struct req_get_entries_v1_st {
  uint64_t start_size;
  uint64_t end_size;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct req_get_entries_v1_st req_get_entries_v1_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_REQ_GET_PROOF_BY_HASH_V1)
struct req_get_proof_by_hash_v1_st {
  uint64_t tree_size;
  uint8_t leaf_hash[32];
  uint8_t trunnel_error_code_;
};
#endif
typedef struct req_get_proof_by_hash_v1_st req_get_proof_by_hash_v1_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_SIGIDENT_ED25519)
struct sigident_ed25519_st {
  uint8_t signature[64];
  uint8_t identifier[32];
  uint8_t trunnel_error_code_;
};
#endif
typedef struct sigident_ed25519_st sigident_ed25519_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_SIGNED_CHECKSUM32_ED25519)
struct signed_checksum32_ed25519_st {
  uint8_t checksum[32];
  uint64_t length;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) identifier;
  uint8_t signature[64];
  uint8_t namespace[32];
  uint8_t trunnel_error_code_;
};
#endif
typedef struct signed_checksum32_ed25519_st signed_checksum32_ed25519_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_CONSISTENCY_PROOF_V1)
struct consistency_proof_v1_st {
  uint64_t magic;
  uint64_t format;
  uint8_t identifier[32];
  uint64_t old_size;
  uint64_t new_size;
  uint64_t n_items;
  TRUNNEL_DYNARRAY_HEAD(, struct hash_st *) hashes;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct consistency_proof_v1_st consistency_proof_v1_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_ENTRIES_V1)
struct entries_v1_st {
  uint64_t magic;
  uint64_t format;
  uint64_t n_items;
  TRUNNEL_DYNARRAY_HEAD(, struct signed_checksum32_ed25519_st *) checksums;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct entries_v1_st entries_v1_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_INCLUSION_PROOF_V1)
struct inclusion_proof_v1_st {
  uint64_t magic;
  uint64_t format;
  uint8_t identifier[32];
  uint64_t tree_size;
  uint64_t leaf_index;
  uint64_t n_items;
  TRUNNEL_DYNARRAY_HEAD(, struct hash_st *) hashes;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct inclusion_proof_v1_st inclusion_proof_v1_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_REQUEST_V1)
struct request_v1_st {
  uint64_t magic;
  uint64_t format;
  struct req_get_entries_v1_st *request_get_entries;
  struct req_get_proof_by_hash_v1_st *request_get_proof_by_hash;
  struct req_get_consistency_proof_v1_st *request_get_consistency_proof;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct request_v1_st request_v1_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_SIGNED_TREE_HEAD_V1)
struct signed_tree_head_v1_st {
  uint64_t magic;
  uint64_t format;
  uint64_t timestamp;
  uint64_t tree_size;
  uint8_t root_hash[32];
  uint64_t n_items;
  TRUNNEL_DYNARRAY_HEAD(, struct sigident_ed25519_st *) signatures;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct signed_tree_head_v1_st signed_tree_head_v1_t;
/** Return a newly allocated hash with all elements set to zero.
 */
hash_t *hash_new(void);
/** Release all storage held by the hash in 'victim'. (Do nothing if
 * 'victim' is NULL.)
 */
void hash_free(hash_t *victim);
/** Try to parse a hash from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated hash_t. On
 * failure, return -2 if the input appears truncated, and -1 if the
 * input is otherwise invalid.
 */
ssize_t hash_parse(hash_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the hash in
 * 'obj'. On failure, return a negative value. Note that this value
 * may be an overestimate, and can even be an underestimate for
 * certain unencodeable objects.
 */
ssize_t hash_encoded_len(const hash_t *obj);
/** Try to encode the hash from 'input' into the buffer at 'output',
 * using up to 'avail' bytes of the output buffer. On success, return
 * the number of bytes used. On failure, return -2 if the buffer was
 * not long enough, and -1 if the input was invalid.
 */
ssize_t hash_encode(uint8_t *output, size_t avail, const hash_t *input);
/** Check whether the internal state of the hash in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *hash_check(const hash_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int hash_clear_errors(hash_t *obj);
/** Return the (constant) length of the array holding the hash field
 * of the hash_t in 'inp'.
 */
size_t hash_getlen_hash(const hash_t *inp);
/** Return the element at position 'idx' of the fixed array field hash
 * of the hash_t in 'inp'.
 */
uint8_t hash_get_hash(hash_t *inp, size_t idx);
/** As hash_get_hash, but take and return a const pointer
 */
uint8_t hash_getconst_hash(const hash_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field hash
 * of the hash_t in 'inp', so that it will hold the value 'elt'.
 */
int hash_set_hash(hash_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the 32-element array field hash of 'inp'.
 */
uint8_t * hash_getarray_hash(hash_t *inp);
/** As hash_get_hash, but take and return a const pointer
 */
const uint8_t  * hash_getconstarray_hash(const hash_t *inp);
/** Return a newly allocated req_get_consistency_proof_v1 with all
 * elements set to zero.
 */
req_get_consistency_proof_v1_t *req_get_consistency_proof_v1_new(void);
/** Release all storage held by the req_get_consistency_proof_v1 in
 * 'victim'. (Do nothing if 'victim' is NULL.)
 */
void req_get_consistency_proof_v1_free(req_get_consistency_proof_v1_t *victim);
/** Try to parse a req_get_consistency_proof_v1 from the buffer in
 * 'input', using up to 'len_in' bytes from the input buffer. On
 * success, return the number of bytes consumed and set *output to the
 * newly allocated req_get_consistency_proof_v1_t. On failure, return
 * -2 if the input appears truncated, and -1 if the input is otherwise
 * invalid.
 */
ssize_t req_get_consistency_proof_v1_parse(req_get_consistency_proof_v1_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * req_get_consistency_proof_v1 in 'obj'. On failure, return a
 * negative value. Note that this value may be an overestimate, and
 * can even be an underestimate for certain unencodeable objects.
 */
ssize_t req_get_consistency_proof_v1_encoded_len(const req_get_consistency_proof_v1_t *obj);
/** Try to encode the req_get_consistency_proof_v1 from 'input' into
 * the buffer at 'output', using up to 'avail' bytes of the output
 * buffer. On success, return the number of bytes used. On failure,
 * return -2 if the buffer was not long enough, and -1 if the input
 * was invalid.
 */
ssize_t req_get_consistency_proof_v1_encode(uint8_t *output, size_t avail, const req_get_consistency_proof_v1_t *input);
/** Check whether the internal state of the
 * req_get_consistency_proof_v1 in 'obj' is consistent. Return NULL if
 * it is, and a short message if it is not.
 */
const char *req_get_consistency_proof_v1_check(const req_get_consistency_proof_v1_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int req_get_consistency_proof_v1_clear_errors(req_get_consistency_proof_v1_t *obj);
/** Return the value of the old_size field of the
 * req_get_consistency_proof_v1_t in 'inp'
 */
uint64_t req_get_consistency_proof_v1_get_old_size(const req_get_consistency_proof_v1_t *inp);
/** Set the value of the old_size field of the
 * req_get_consistency_proof_v1_t in 'inp' to 'val'. Return 0 on
 * success; return -1 and set the error code on 'inp' on failure.
 */
int req_get_consistency_proof_v1_set_old_size(req_get_consistency_proof_v1_t *inp, uint64_t val);
/** Return the value of the new_size field of the
 * req_get_consistency_proof_v1_t in 'inp'
 */
uint64_t req_get_consistency_proof_v1_get_new_size(const req_get_consistency_proof_v1_t *inp);
/** Set the value of the new_size field of the
 * req_get_consistency_proof_v1_t in 'inp' to 'val'. Return 0 on
 * success; return -1 and set the error code on 'inp' on failure.
 */
int req_get_consistency_proof_v1_set_new_size(req_get_consistency_proof_v1_t *inp, uint64_t val);
/** Return a newly allocated req_get_entries_v1 with all elements set
 * to zero.
 */
req_get_entries_v1_t *req_get_entries_v1_new(void);
/** Release all storage held by the req_get_entries_v1 in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void req_get_entries_v1_free(req_get_entries_v1_t *victim);
/** Try to parse a req_get_entries_v1 from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated req_get_entries_v1_t. On failure, return -2 if the input
 * appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t req_get_entries_v1_parse(req_get_entries_v1_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * req_get_entries_v1 in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t req_get_entries_v1_encoded_len(const req_get_entries_v1_t *obj);
/** Try to encode the req_get_entries_v1 from 'input' into the buffer
 * at 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t req_get_entries_v1_encode(uint8_t *output, size_t avail, const req_get_entries_v1_t *input);
/** Check whether the internal state of the req_get_entries_v1 in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *req_get_entries_v1_check(const req_get_entries_v1_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int req_get_entries_v1_clear_errors(req_get_entries_v1_t *obj);
/** Return the value of the start_size field of the
 * req_get_entries_v1_t in 'inp'
 */
uint64_t req_get_entries_v1_get_start_size(const req_get_entries_v1_t *inp);
/** Set the value of the start_size field of the req_get_entries_v1_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int req_get_entries_v1_set_start_size(req_get_entries_v1_t *inp, uint64_t val);
/** Return the value of the end_size field of the req_get_entries_v1_t
 * in 'inp'
 */
uint64_t req_get_entries_v1_get_end_size(const req_get_entries_v1_t *inp);
/** Set the value of the end_size field of the req_get_entries_v1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int req_get_entries_v1_set_end_size(req_get_entries_v1_t *inp, uint64_t val);
/** Return a newly allocated req_get_proof_by_hash_v1 with all
 * elements set to zero.
 */
req_get_proof_by_hash_v1_t *req_get_proof_by_hash_v1_new(void);
/** Release all storage held by the req_get_proof_by_hash_v1 in
 * 'victim'. (Do nothing if 'victim' is NULL.)
 */
void req_get_proof_by_hash_v1_free(req_get_proof_by_hash_v1_t *victim);
/** Try to parse a req_get_proof_by_hash_v1 from the buffer in
 * 'input', using up to 'len_in' bytes from the input buffer. On
 * success, return the number of bytes consumed and set *output to the
 * newly allocated req_get_proof_by_hash_v1_t. On failure, return -2
 * if the input appears truncated, and -1 if the input is otherwise
 * invalid.
 */
ssize_t req_get_proof_by_hash_v1_parse(req_get_proof_by_hash_v1_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * req_get_proof_by_hash_v1 in 'obj'. On failure, return a negative
 * value. Note that this value may be an overestimate, and can even be
 * an underestimate for certain unencodeable objects.
 */
ssize_t req_get_proof_by_hash_v1_encoded_len(const req_get_proof_by_hash_v1_t *obj);
/** Try to encode the req_get_proof_by_hash_v1 from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t req_get_proof_by_hash_v1_encode(uint8_t *output, size_t avail, const req_get_proof_by_hash_v1_t *input);
/** Check whether the internal state of the req_get_proof_by_hash_v1
 * in 'obj' is consistent. Return NULL if it is, and a short message
 * if it is not.
 */
const char *req_get_proof_by_hash_v1_check(const req_get_proof_by_hash_v1_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int req_get_proof_by_hash_v1_clear_errors(req_get_proof_by_hash_v1_t *obj);
/** Return the value of the tree_size field of the
 * req_get_proof_by_hash_v1_t in 'inp'
 */
uint64_t req_get_proof_by_hash_v1_get_tree_size(const req_get_proof_by_hash_v1_t *inp);
/** Set the value of the tree_size field of the
 * req_get_proof_by_hash_v1_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int req_get_proof_by_hash_v1_set_tree_size(req_get_proof_by_hash_v1_t *inp, uint64_t val);
/** Return the (constant) length of the array holding the leaf_hash
 * field of the req_get_proof_by_hash_v1_t in 'inp'.
 */
size_t req_get_proof_by_hash_v1_getlen_leaf_hash(const req_get_proof_by_hash_v1_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * leaf_hash of the req_get_proof_by_hash_v1_t in 'inp'.
 */
uint8_t req_get_proof_by_hash_v1_get_leaf_hash(req_get_proof_by_hash_v1_t *inp, size_t idx);
/** As req_get_proof_by_hash_v1_get_leaf_hash, but take and return a
 * const pointer
 */
uint8_t req_get_proof_by_hash_v1_getconst_leaf_hash(const req_get_proof_by_hash_v1_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * leaf_hash of the req_get_proof_by_hash_v1_t in 'inp', so that it
 * will hold the value 'elt'.
 */
int req_get_proof_by_hash_v1_set_leaf_hash(req_get_proof_by_hash_v1_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the 32-element array field leaf_hash of 'inp'.
 */
uint8_t * req_get_proof_by_hash_v1_getarray_leaf_hash(req_get_proof_by_hash_v1_t *inp);
/** As req_get_proof_by_hash_v1_get_leaf_hash, but take and return a
 * const pointer
 */
const uint8_t  * req_get_proof_by_hash_v1_getconstarray_leaf_hash(const req_get_proof_by_hash_v1_t *inp);
/** Return a newly allocated sigident_ed25519 with all elements set to
 * zero.
 */
sigident_ed25519_t *sigident_ed25519_new(void);
/** Release all storage held by the sigident_ed25519 in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void sigident_ed25519_free(sigident_ed25519_t *victim);
/** Try to parse a sigident_ed25519 from the buffer in 'input', using
 * up to 'len_in' bytes from the input buffer. On success, return the
 * number of bytes consumed and set *output to the newly allocated
 * sigident_ed25519_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t sigident_ed25519_parse(sigident_ed25519_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * sigident_ed25519 in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t sigident_ed25519_encoded_len(const sigident_ed25519_t *obj);
/** Try to encode the sigident_ed25519 from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t sigident_ed25519_encode(uint8_t *output, size_t avail, const sigident_ed25519_t *input);
/** Check whether the internal state of the sigident_ed25519 in 'obj'
 * is consistent. Return NULL if it is, and a short message if it is
 * not.
 */
const char *sigident_ed25519_check(const sigident_ed25519_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int sigident_ed25519_clear_errors(sigident_ed25519_t *obj);
/** Return the (constant) length of the array holding the signature
 * field of the sigident_ed25519_t in 'inp'.
 */
size_t sigident_ed25519_getlen_signature(const sigident_ed25519_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * signature of the sigident_ed25519_t in 'inp'.
 */
uint8_t sigident_ed25519_get_signature(sigident_ed25519_t *inp, size_t idx);
/** As sigident_ed25519_get_signature, but take and return a const
 * pointer
 */
uint8_t sigident_ed25519_getconst_signature(const sigident_ed25519_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * signature of the sigident_ed25519_t in 'inp', so that it will hold
 * the value 'elt'.
 */
int sigident_ed25519_set_signature(sigident_ed25519_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the 64-element array field signature of 'inp'.
 */
uint8_t * sigident_ed25519_getarray_signature(sigident_ed25519_t *inp);
/** As sigident_ed25519_get_signature, but take and return a const
 * pointer
 */
const uint8_t  * sigident_ed25519_getconstarray_signature(const sigident_ed25519_t *inp);
/** Return the (constant) length of the array holding the identifier
 * field of the sigident_ed25519_t in 'inp'.
 */
size_t sigident_ed25519_getlen_identifier(const sigident_ed25519_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * identifier of the sigident_ed25519_t in 'inp'.
 */
uint8_t sigident_ed25519_get_identifier(sigident_ed25519_t *inp, size_t idx);
/** As sigident_ed25519_get_identifier, but take and return a const
 * pointer
 */
uint8_t sigident_ed25519_getconst_identifier(const sigident_ed25519_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * identifier of the sigident_ed25519_t in 'inp', so that it will hold
 * the value 'elt'.
 */
int sigident_ed25519_set_identifier(sigident_ed25519_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the 32-element array field identifier of
 * 'inp'.
 */
uint8_t * sigident_ed25519_getarray_identifier(sigident_ed25519_t *inp);
/** As sigident_ed25519_get_identifier, but take and return a const
 * pointer
 */
const uint8_t  * sigident_ed25519_getconstarray_identifier(const sigident_ed25519_t *inp);
/** Return a newly allocated signed_checksum32_ed25519 with all
 * elements set to zero.
 */
signed_checksum32_ed25519_t *signed_checksum32_ed25519_new(void);
/** Release all storage held by the signed_checksum32_ed25519 in
 * 'victim'. (Do nothing if 'victim' is NULL.)
 */
void signed_checksum32_ed25519_free(signed_checksum32_ed25519_t *victim);
/** Try to parse a signed_checksum32_ed25519 from the buffer in
 * 'input', using up to 'len_in' bytes from the input buffer. On
 * success, return the number of bytes consumed and set *output to the
 * newly allocated signed_checksum32_ed25519_t. On failure, return -2
 * if the input appears truncated, and -1 if the input is otherwise
 * invalid.
 */
ssize_t signed_checksum32_ed25519_parse(signed_checksum32_ed25519_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * signed_checksum32_ed25519 in 'obj'. On failure, return a negative
 * value. Note that this value may be an overestimate, and can even be
 * an underestimate for certain unencodeable objects.
 */
ssize_t signed_checksum32_ed25519_encoded_len(const signed_checksum32_ed25519_t *obj);
/** Try to encode the signed_checksum32_ed25519 from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t signed_checksum32_ed25519_encode(uint8_t *output, size_t avail, const signed_checksum32_ed25519_t *input);
/** Check whether the internal state of the signed_checksum32_ed25519
 * in 'obj' is consistent. Return NULL if it is, and a short message
 * if it is not.
 */
const char *signed_checksum32_ed25519_check(const signed_checksum32_ed25519_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int signed_checksum32_ed25519_clear_errors(signed_checksum32_ed25519_t *obj);
/** Return the (constant) length of the array holding the checksum
 * field of the signed_checksum32_ed25519_t in 'inp'.
 */
size_t signed_checksum32_ed25519_getlen_checksum(const signed_checksum32_ed25519_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * checksum of the signed_checksum32_ed25519_t in 'inp'.
 */
uint8_t signed_checksum32_ed25519_get_checksum(signed_checksum32_ed25519_t *inp, size_t idx);
/** As signed_checksum32_ed25519_get_checksum, but take and return a
 * const pointer
 */
uint8_t signed_checksum32_ed25519_getconst_checksum(const signed_checksum32_ed25519_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * checksum of the signed_checksum32_ed25519_t in 'inp', so that it
 * will hold the value 'elt'.
 */
int signed_checksum32_ed25519_set_checksum(signed_checksum32_ed25519_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the 32-element array field checksum of 'inp'.
 */
uint8_t * signed_checksum32_ed25519_getarray_checksum(signed_checksum32_ed25519_t *inp);
/** As signed_checksum32_ed25519_get_checksum, but take and return a
 * const pointer
 */
const uint8_t  * signed_checksum32_ed25519_getconstarray_checksum(const signed_checksum32_ed25519_t *inp);
/** Return the value of the length field of the
 * signed_checksum32_ed25519_t in 'inp'
 */
uint64_t signed_checksum32_ed25519_get_length(const signed_checksum32_ed25519_t *inp);
/** Set the value of the length field of the
 * signed_checksum32_ed25519_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int signed_checksum32_ed25519_set_length(signed_checksum32_ed25519_t *inp, uint64_t val);
/** Return the length of the dynamic array holding the identifier
 * field of the signed_checksum32_ed25519_t in 'inp'.
 */
size_t signed_checksum32_ed25519_getlen_identifier(const signed_checksum32_ed25519_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * identifier of the signed_checksum32_ed25519_t in 'inp'.
 */
uint8_t signed_checksum32_ed25519_get_identifier(signed_checksum32_ed25519_t *inp, size_t idx);
/** As signed_checksum32_ed25519_get_identifier, but take and return a
 * const pointer
 */
uint8_t signed_checksum32_ed25519_getconst_identifier(const signed_checksum32_ed25519_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * identifier of the signed_checksum32_ed25519_t in 'inp', so that it
 * will hold the value 'elt'.
 */
int signed_checksum32_ed25519_set_identifier(signed_checksum32_ed25519_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field identifier
 * of the signed_checksum32_ed25519_t in 'inp'.
 */
int signed_checksum32_ed25519_add_identifier(signed_checksum32_ed25519_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field identifier of
 * 'inp'.
 */
uint8_t * signed_checksum32_ed25519_getarray_identifier(signed_checksum32_ed25519_t *inp);
/** As signed_checksum32_ed25519_get_identifier, but take and return a
 * const pointer
 */
const uint8_t  * signed_checksum32_ed25519_getconstarray_identifier(const signed_checksum32_ed25519_t *inp);
/** Change the length of the variable-length array field identifier of
 * 'inp' to 'newlen'.Fill extra elements with 0. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int signed_checksum32_ed25519_setlen_identifier(signed_checksum32_ed25519_t *inp, size_t newlen);
/** Return the (constant) length of the array holding the signature
 * field of the signed_checksum32_ed25519_t in 'inp'.
 */
size_t signed_checksum32_ed25519_getlen_signature(const signed_checksum32_ed25519_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * signature of the signed_checksum32_ed25519_t in 'inp'.
 */
uint8_t signed_checksum32_ed25519_get_signature(signed_checksum32_ed25519_t *inp, size_t idx);
/** As signed_checksum32_ed25519_get_signature, but take and return a
 * const pointer
 */
uint8_t signed_checksum32_ed25519_getconst_signature(const signed_checksum32_ed25519_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * signature of the signed_checksum32_ed25519_t in 'inp', so that it
 * will hold the value 'elt'.
 */
int signed_checksum32_ed25519_set_signature(signed_checksum32_ed25519_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the 64-element array field signature of 'inp'.
 */
uint8_t * signed_checksum32_ed25519_getarray_signature(signed_checksum32_ed25519_t *inp);
/** As signed_checksum32_ed25519_get_signature, but take and return a
 * const pointer
 */
const uint8_t  * signed_checksum32_ed25519_getconstarray_signature(const signed_checksum32_ed25519_t *inp);
/** Return the (constant) length of the array holding the namespace
 * field of the signed_checksum32_ed25519_t in 'inp'.
 */
size_t signed_checksum32_ed25519_getlen_namespace(const signed_checksum32_ed25519_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * namespace of the signed_checksum32_ed25519_t in 'inp'.
 */
uint8_t signed_checksum32_ed25519_get_namespace(signed_checksum32_ed25519_t *inp, size_t idx);
/** As signed_checksum32_ed25519_get_namespace, but take and return a
 * const pointer
 */
uint8_t signed_checksum32_ed25519_getconst_namespace(const signed_checksum32_ed25519_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * namespace of the signed_checksum32_ed25519_t in 'inp', so that it
 * will hold the value 'elt'.
 */
int signed_checksum32_ed25519_set_namespace(signed_checksum32_ed25519_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the 32-element array field namespace of 'inp'.
 */
uint8_t * signed_checksum32_ed25519_getarray_namespace(signed_checksum32_ed25519_t *inp);
/** As signed_checksum32_ed25519_get_namespace, but take and return a
 * const pointer
 */
const uint8_t  * signed_checksum32_ed25519_getconstarray_namespace(const signed_checksum32_ed25519_t *inp);
/** Return a newly allocated consistency_proof_v1 with all elements
 * set to zero.
 */
consistency_proof_v1_t *consistency_proof_v1_new(void);
/** Release all storage held by the consistency_proof_v1 in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void consistency_proof_v1_free(consistency_proof_v1_t *victim);
/** Try to parse a consistency_proof_v1 from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated consistency_proof_v1_t. On failure, return -2 if the
 * input appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t consistency_proof_v1_parse(consistency_proof_v1_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * consistency_proof_v1 in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t consistency_proof_v1_encoded_len(const consistency_proof_v1_t *obj);
/** Try to encode the consistency_proof_v1 from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t consistency_proof_v1_encode(uint8_t *output, size_t avail, const consistency_proof_v1_t *input);
/** Check whether the internal state of the consistency_proof_v1 in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *consistency_proof_v1_check(const consistency_proof_v1_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int consistency_proof_v1_clear_errors(consistency_proof_v1_t *obj);
/** Return the value of the magic field of the consistency_proof_v1_t
 * in 'inp'
 */
uint64_t consistency_proof_v1_get_magic(const consistency_proof_v1_t *inp);
/** Set the value of the magic field of the consistency_proof_v1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int consistency_proof_v1_set_magic(consistency_proof_v1_t *inp, uint64_t val);
/** Return the value of the format field of the consistency_proof_v1_t
 * in 'inp'
 */
uint64_t consistency_proof_v1_get_format(const consistency_proof_v1_t *inp);
/** Set the value of the format field of the consistency_proof_v1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int consistency_proof_v1_set_format(consistency_proof_v1_t *inp, uint64_t val);
/** Return the (constant) length of the array holding the identifier
 * field of the consistency_proof_v1_t in 'inp'.
 */
size_t consistency_proof_v1_getlen_identifier(const consistency_proof_v1_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * identifier of the consistency_proof_v1_t in 'inp'.
 */
uint8_t consistency_proof_v1_get_identifier(consistency_proof_v1_t *inp, size_t idx);
/** As consistency_proof_v1_get_identifier, but take and return a
 * const pointer
 */
uint8_t consistency_proof_v1_getconst_identifier(const consistency_proof_v1_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * identifier of the consistency_proof_v1_t in 'inp', so that it will
 * hold the value 'elt'.
 */
int consistency_proof_v1_set_identifier(consistency_proof_v1_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the 32-element array field identifier of
 * 'inp'.
 */
uint8_t * consistency_proof_v1_getarray_identifier(consistency_proof_v1_t *inp);
/** As consistency_proof_v1_get_identifier, but take and return a
 * const pointer
 */
const uint8_t  * consistency_proof_v1_getconstarray_identifier(const consistency_proof_v1_t *inp);
/** Return the value of the old_size field of the
 * consistency_proof_v1_t in 'inp'
 */
uint64_t consistency_proof_v1_get_old_size(const consistency_proof_v1_t *inp);
/** Set the value of the old_size field of the consistency_proof_v1_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int consistency_proof_v1_set_old_size(consistency_proof_v1_t *inp, uint64_t val);
/** Return the value of the new_size field of the
 * consistency_proof_v1_t in 'inp'
 */
uint64_t consistency_proof_v1_get_new_size(const consistency_proof_v1_t *inp);
/** Set the value of the new_size field of the consistency_proof_v1_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int consistency_proof_v1_set_new_size(consistency_proof_v1_t *inp, uint64_t val);
/** Return the value of the n_items field of the
 * consistency_proof_v1_t in 'inp'
 */
uint64_t consistency_proof_v1_get_n_items(const consistency_proof_v1_t *inp);
/** Set the value of the n_items field of the consistency_proof_v1_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int consistency_proof_v1_set_n_items(consistency_proof_v1_t *inp, uint64_t val);
/** Return the length of the dynamic array holding the hashes field of
 * the consistency_proof_v1_t in 'inp'.
 */
size_t consistency_proof_v1_getlen_hashes(const consistency_proof_v1_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * hashes of the consistency_proof_v1_t in 'inp'.
 */
struct hash_st * consistency_proof_v1_get_hashes(consistency_proof_v1_t *inp, size_t idx);
/** As consistency_proof_v1_get_hashes, but take and return a const
 * pointer
 */
 const struct hash_st * consistency_proof_v1_getconst_hashes(const consistency_proof_v1_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * hashes of the consistency_proof_v1_t in 'inp', so that it will hold
 * the value 'elt'. Free the previous value, if any.
 */
int consistency_proof_v1_set_hashes(consistency_proof_v1_t *inp, size_t idx, struct hash_st * elt);
/** As consistency_proof_v1_set_hashes, but does not free the previous
 * value.
 */
int consistency_proof_v1_set0_hashes(consistency_proof_v1_t *inp, size_t idx, struct hash_st * elt);
/** Append a new element 'elt' to the dynamic array field hashes of
 * the consistency_proof_v1_t in 'inp'.
 */
int consistency_proof_v1_add_hashes(consistency_proof_v1_t *inp, struct hash_st * elt);
/** Return a pointer to the variable-length array field hashes of
 * 'inp'.
 */
struct hash_st * * consistency_proof_v1_getarray_hashes(consistency_proof_v1_t *inp);
/** As consistency_proof_v1_get_hashes, but take and return a const
 * pointer
 */
const struct hash_st *  const  * consistency_proof_v1_getconstarray_hashes(const consistency_proof_v1_t *inp);
/** Change the length of the variable-length array field hashes of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int consistency_proof_v1_setlen_hashes(consistency_proof_v1_t *inp, size_t newlen);
/** Return a newly allocated entries_v1 with all elements set to zero.
 */
entries_v1_t *entries_v1_new(void);
/** Release all storage held by the entries_v1 in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void entries_v1_free(entries_v1_t *victim);
/** Try to parse a entries_v1 from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated
 * entries_v1_t. On failure, return -2 if the input appears truncated,
 * and -1 if the input is otherwise invalid.
 */
ssize_t entries_v1_parse(entries_v1_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * entries_v1 in 'obj'. On failure, return a negative value. Note that
 * this value may be an overestimate, and can even be an underestimate
 * for certain unencodeable objects.
 */
ssize_t entries_v1_encoded_len(const entries_v1_t *obj);
/** Try to encode the entries_v1 from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t entries_v1_encode(uint8_t *output, size_t avail, const entries_v1_t *input);
/** Check whether the internal state of the entries_v1 in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *entries_v1_check(const entries_v1_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int entries_v1_clear_errors(entries_v1_t *obj);
/** Return the value of the magic field of the entries_v1_t in 'inp'
 */
uint64_t entries_v1_get_magic(const entries_v1_t *inp);
/** Set the value of the magic field of the entries_v1_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int entries_v1_set_magic(entries_v1_t *inp, uint64_t val);
/** Return the value of the format field of the entries_v1_t in 'inp'
 */
uint64_t entries_v1_get_format(const entries_v1_t *inp);
/** Set the value of the format field of the entries_v1_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int entries_v1_set_format(entries_v1_t *inp, uint64_t val);
/** Return the value of the n_items field of the entries_v1_t in 'inp'
 */
uint64_t entries_v1_get_n_items(const entries_v1_t *inp);
/** Set the value of the n_items field of the entries_v1_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int entries_v1_set_n_items(entries_v1_t *inp, uint64_t val);
/** Return the length of the dynamic array holding the checksums field
 * of the entries_v1_t in 'inp'.
 */
size_t entries_v1_getlen_checksums(const entries_v1_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * checksums of the entries_v1_t in 'inp'.
 */
struct signed_checksum32_ed25519_st * entries_v1_get_checksums(entries_v1_t *inp, size_t idx);
/** As entries_v1_get_checksums, but take and return a const pointer
 */
 const struct signed_checksum32_ed25519_st * entries_v1_getconst_checksums(const entries_v1_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * checksums of the entries_v1_t in 'inp', so that it will hold the
 * value 'elt'. Free the previous value, if any.
 */
int entries_v1_set_checksums(entries_v1_t *inp, size_t idx, struct signed_checksum32_ed25519_st * elt);
/** As entries_v1_set_checksums, but does not free the previous value.
 */
int entries_v1_set0_checksums(entries_v1_t *inp, size_t idx, struct signed_checksum32_ed25519_st * elt);
/** Append a new element 'elt' to the dynamic array field checksums of
 * the entries_v1_t in 'inp'.
 */
int entries_v1_add_checksums(entries_v1_t *inp, struct signed_checksum32_ed25519_st * elt);
/** Return a pointer to the variable-length array field checksums of
 * 'inp'.
 */
struct signed_checksum32_ed25519_st * * entries_v1_getarray_checksums(entries_v1_t *inp);
/** As entries_v1_get_checksums, but take and return a const pointer
 */
const struct signed_checksum32_ed25519_st *  const  * entries_v1_getconstarray_checksums(const entries_v1_t *inp);
/** Change the length of the variable-length array field checksums of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int entries_v1_setlen_checksums(entries_v1_t *inp, size_t newlen);
/** Return a newly allocated inclusion_proof_v1 with all elements set
 * to zero.
 */
inclusion_proof_v1_t *inclusion_proof_v1_new(void);
/** Release all storage held by the inclusion_proof_v1 in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void inclusion_proof_v1_free(inclusion_proof_v1_t *victim);
/** Try to parse a inclusion_proof_v1 from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated inclusion_proof_v1_t. On failure, return -2 if the input
 * appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t inclusion_proof_v1_parse(inclusion_proof_v1_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * inclusion_proof_v1 in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t inclusion_proof_v1_encoded_len(const inclusion_proof_v1_t *obj);
/** Try to encode the inclusion_proof_v1 from 'input' into the buffer
 * at 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t inclusion_proof_v1_encode(uint8_t *output, size_t avail, const inclusion_proof_v1_t *input);
/** Check whether the internal state of the inclusion_proof_v1 in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *inclusion_proof_v1_check(const inclusion_proof_v1_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int inclusion_proof_v1_clear_errors(inclusion_proof_v1_t *obj);
/** Return the value of the magic field of the inclusion_proof_v1_t in
 * 'inp'
 */
uint64_t inclusion_proof_v1_get_magic(const inclusion_proof_v1_t *inp);
/** Set the value of the magic field of the inclusion_proof_v1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int inclusion_proof_v1_set_magic(inclusion_proof_v1_t *inp, uint64_t val);
/** Return the value of the format field of the inclusion_proof_v1_t
 * in 'inp'
 */
uint64_t inclusion_proof_v1_get_format(const inclusion_proof_v1_t *inp);
/** Set the value of the format field of the inclusion_proof_v1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int inclusion_proof_v1_set_format(inclusion_proof_v1_t *inp, uint64_t val);
/** Return the (constant) length of the array holding the identifier
 * field of the inclusion_proof_v1_t in 'inp'.
 */
size_t inclusion_proof_v1_getlen_identifier(const inclusion_proof_v1_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * identifier of the inclusion_proof_v1_t in 'inp'.
 */
uint8_t inclusion_proof_v1_get_identifier(inclusion_proof_v1_t *inp, size_t idx);
/** As inclusion_proof_v1_get_identifier, but take and return a const
 * pointer
 */
uint8_t inclusion_proof_v1_getconst_identifier(const inclusion_proof_v1_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * identifier of the inclusion_proof_v1_t in 'inp', so that it will
 * hold the value 'elt'.
 */
int inclusion_proof_v1_set_identifier(inclusion_proof_v1_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the 32-element array field identifier of
 * 'inp'.
 */
uint8_t * inclusion_proof_v1_getarray_identifier(inclusion_proof_v1_t *inp);
/** As inclusion_proof_v1_get_identifier, but take and return a const
 * pointer
 */
const uint8_t  * inclusion_proof_v1_getconstarray_identifier(const inclusion_proof_v1_t *inp);
/** Return the value of the tree_size field of the
 * inclusion_proof_v1_t in 'inp'
 */
uint64_t inclusion_proof_v1_get_tree_size(const inclusion_proof_v1_t *inp);
/** Set the value of the tree_size field of the inclusion_proof_v1_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int inclusion_proof_v1_set_tree_size(inclusion_proof_v1_t *inp, uint64_t val);
/** Return the value of the leaf_index field of the
 * inclusion_proof_v1_t in 'inp'
 */
uint64_t inclusion_proof_v1_get_leaf_index(const inclusion_proof_v1_t *inp);
/** Set the value of the leaf_index field of the inclusion_proof_v1_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int inclusion_proof_v1_set_leaf_index(inclusion_proof_v1_t *inp, uint64_t val);
/** Return the value of the n_items field of the inclusion_proof_v1_t
 * in 'inp'
 */
uint64_t inclusion_proof_v1_get_n_items(const inclusion_proof_v1_t *inp);
/** Set the value of the n_items field of the inclusion_proof_v1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int inclusion_proof_v1_set_n_items(inclusion_proof_v1_t *inp, uint64_t val);
/** Return the length of the dynamic array holding the hashes field of
 * the inclusion_proof_v1_t in 'inp'.
 */
size_t inclusion_proof_v1_getlen_hashes(const inclusion_proof_v1_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * hashes of the inclusion_proof_v1_t in 'inp'.
 */
struct hash_st * inclusion_proof_v1_get_hashes(inclusion_proof_v1_t *inp, size_t idx);
/** As inclusion_proof_v1_get_hashes, but take and return a const
 * pointer
 */
 const struct hash_st * inclusion_proof_v1_getconst_hashes(const inclusion_proof_v1_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * hashes of the inclusion_proof_v1_t in 'inp', so that it will hold
 * the value 'elt'. Free the previous value, if any.
 */
int inclusion_proof_v1_set_hashes(inclusion_proof_v1_t *inp, size_t idx, struct hash_st * elt);
/** As inclusion_proof_v1_set_hashes, but does not free the previous
 * value.
 */
int inclusion_proof_v1_set0_hashes(inclusion_proof_v1_t *inp, size_t idx, struct hash_st * elt);
/** Append a new element 'elt' to the dynamic array field hashes of
 * the inclusion_proof_v1_t in 'inp'.
 */
int inclusion_proof_v1_add_hashes(inclusion_proof_v1_t *inp, struct hash_st * elt);
/** Return a pointer to the variable-length array field hashes of
 * 'inp'.
 */
struct hash_st * * inclusion_proof_v1_getarray_hashes(inclusion_proof_v1_t *inp);
/** As inclusion_proof_v1_get_hashes, but take and return a const
 * pointer
 */
const struct hash_st *  const  * inclusion_proof_v1_getconstarray_hashes(const inclusion_proof_v1_t *inp);
/** Change the length of the variable-length array field hashes of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int inclusion_proof_v1_setlen_hashes(inclusion_proof_v1_t *inp, size_t newlen);
/** Return a newly allocated request_v1 with all elements set to zero.
 */
request_v1_t *request_v1_new(void);
/** Release all storage held by the request_v1 in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void request_v1_free(request_v1_t *victim);
/** Try to parse a request_v1 from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated
 * request_v1_t. On failure, return -2 if the input appears truncated,
 * and -1 if the input is otherwise invalid.
 */
ssize_t request_v1_parse(request_v1_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * request_v1 in 'obj'. On failure, return a negative value. Note that
 * this value may be an overestimate, and can even be an underestimate
 * for certain unencodeable objects.
 */
ssize_t request_v1_encoded_len(const request_v1_t *obj);
/** Try to encode the request_v1 from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t request_v1_encode(uint8_t *output, size_t avail, const request_v1_t *input);
/** Check whether the internal state of the request_v1 in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *request_v1_check(const request_v1_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int request_v1_clear_errors(request_v1_t *obj);
/** Return the value of the magic field of the request_v1_t in 'inp'
 */
uint64_t request_v1_get_magic(const request_v1_t *inp);
/** Set the value of the magic field of the request_v1_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int request_v1_set_magic(request_v1_t *inp, uint64_t val);
/** Return the value of the format field of the request_v1_t in 'inp'
 */
uint64_t request_v1_get_format(const request_v1_t *inp);
/** Set the value of the format field of the request_v1_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int request_v1_set_format(request_v1_t *inp, uint64_t val);
/** Return the value of the request_get_entries field of the
 * request_v1_t in 'inp'
 */
struct req_get_entries_v1_st * request_v1_get_request_get_entries(request_v1_t *inp);
/** As request_v1_get_request_get_entries, but take and return a const
 * pointer
 */
const struct req_get_entries_v1_st * request_v1_getconst_request_get_entries(const request_v1_t *inp);
/** Set the value of the request_get_entries field of the request_v1_t
 * in 'inp' to 'val'. Free the old value if any. Steals the
 * referenceto 'val'.Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int request_v1_set_request_get_entries(request_v1_t *inp, struct req_get_entries_v1_st *val);
/** As request_v1_set_request_get_entries, but does not free the
 * previous value.
 */
int request_v1_set0_request_get_entries(request_v1_t *inp, struct req_get_entries_v1_st *val);
/** Return the value of the request_get_proof_by_hash field of the
 * request_v1_t in 'inp'
 */
struct req_get_proof_by_hash_v1_st * request_v1_get_request_get_proof_by_hash(request_v1_t *inp);
/** As request_v1_get_request_get_proof_by_hash, but take and return a
 * const pointer
 */
const struct req_get_proof_by_hash_v1_st * request_v1_getconst_request_get_proof_by_hash(const request_v1_t *inp);
/** Set the value of the request_get_proof_by_hash field of the
 * request_v1_t in 'inp' to 'val'. Free the old value if any. Steals
 * the referenceto 'val'.Return 0 on success; return -1 and set the
 * error code on 'inp' on failure.
 */
int request_v1_set_request_get_proof_by_hash(request_v1_t *inp, struct req_get_proof_by_hash_v1_st *val);
/** As request_v1_set_request_get_proof_by_hash, but does not free the
 * previous value.
 */
int request_v1_set0_request_get_proof_by_hash(request_v1_t *inp, struct req_get_proof_by_hash_v1_st *val);
/** Return the value of the request_get_consistency_proof field of the
 * request_v1_t in 'inp'
 */
struct req_get_consistency_proof_v1_st * request_v1_get_request_get_consistency_proof(request_v1_t *inp);
/** As request_v1_get_request_get_consistency_proof, but take and
 * return a const pointer
 */
const struct req_get_consistency_proof_v1_st * request_v1_getconst_request_get_consistency_proof(const request_v1_t *inp);
/** Set the value of the request_get_consistency_proof field of the
 * request_v1_t in 'inp' to 'val'. Free the old value if any. Steals
 * the referenceto 'val'.Return 0 on success; return -1 and set the
 * error code on 'inp' on failure.
 */
int request_v1_set_request_get_consistency_proof(request_v1_t *inp, struct req_get_consistency_proof_v1_st *val);
/** As request_v1_set_request_get_consistency_proof, but does not free
 * the previous value.
 */
int request_v1_set0_request_get_consistency_proof(request_v1_t *inp, struct req_get_consistency_proof_v1_st *val);
/** Return a newly allocated signed_tree_head_v1 with all elements set
 * to zero.
 */
signed_tree_head_v1_t *signed_tree_head_v1_new(void);
/** Release all storage held by the signed_tree_head_v1 in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void signed_tree_head_v1_free(signed_tree_head_v1_t *victim);
/** Try to parse a signed_tree_head_v1 from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated signed_tree_head_v1_t. On failure, return -2 if the input
 * appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t signed_tree_head_v1_parse(signed_tree_head_v1_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * signed_tree_head_v1 in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t signed_tree_head_v1_encoded_len(const signed_tree_head_v1_t *obj);
/** Try to encode the signed_tree_head_v1 from 'input' into the buffer
 * at 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t signed_tree_head_v1_encode(uint8_t *output, size_t avail, const signed_tree_head_v1_t *input);
/** Check whether the internal state of the signed_tree_head_v1 in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *signed_tree_head_v1_check(const signed_tree_head_v1_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int signed_tree_head_v1_clear_errors(signed_tree_head_v1_t *obj);
/** Return the value of the magic field of the signed_tree_head_v1_t
 * in 'inp'
 */
uint64_t signed_tree_head_v1_get_magic(const signed_tree_head_v1_t *inp);
/** Set the value of the magic field of the signed_tree_head_v1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int signed_tree_head_v1_set_magic(signed_tree_head_v1_t *inp, uint64_t val);
/** Return the value of the format field of the signed_tree_head_v1_t
 * in 'inp'
 */
uint64_t signed_tree_head_v1_get_format(const signed_tree_head_v1_t *inp);
/** Set the value of the format field of the signed_tree_head_v1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int signed_tree_head_v1_set_format(signed_tree_head_v1_t *inp, uint64_t val);
/** Return the value of the timestamp field of the
 * signed_tree_head_v1_t in 'inp'
 */
uint64_t signed_tree_head_v1_get_timestamp(const signed_tree_head_v1_t *inp);
/** Set the value of the timestamp field of the signed_tree_head_v1_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int signed_tree_head_v1_set_timestamp(signed_tree_head_v1_t *inp, uint64_t val);
/** Return the value of the tree_size field of the
 * signed_tree_head_v1_t in 'inp'
 */
uint64_t signed_tree_head_v1_get_tree_size(const signed_tree_head_v1_t *inp);
/** Set the value of the tree_size field of the signed_tree_head_v1_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int signed_tree_head_v1_set_tree_size(signed_tree_head_v1_t *inp, uint64_t val);
/** Return the (constant) length of the array holding the root_hash
 * field of the signed_tree_head_v1_t in 'inp'.
 */
size_t signed_tree_head_v1_getlen_root_hash(const signed_tree_head_v1_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * root_hash of the signed_tree_head_v1_t in 'inp'.
 */
uint8_t signed_tree_head_v1_get_root_hash(signed_tree_head_v1_t *inp, size_t idx);
/** As signed_tree_head_v1_get_root_hash, but take and return a const
 * pointer
 */
uint8_t signed_tree_head_v1_getconst_root_hash(const signed_tree_head_v1_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * root_hash of the signed_tree_head_v1_t in 'inp', so that it will
 * hold the value 'elt'.
 */
int signed_tree_head_v1_set_root_hash(signed_tree_head_v1_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the 32-element array field root_hash of 'inp'.
 */
uint8_t * signed_tree_head_v1_getarray_root_hash(signed_tree_head_v1_t *inp);
/** As signed_tree_head_v1_get_root_hash, but take and return a const
 * pointer
 */
const uint8_t  * signed_tree_head_v1_getconstarray_root_hash(const signed_tree_head_v1_t *inp);
/** Return the value of the n_items field of the signed_tree_head_v1_t
 * in 'inp'
 */
uint64_t signed_tree_head_v1_get_n_items(const signed_tree_head_v1_t *inp);
/** Set the value of the n_items field of the signed_tree_head_v1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int signed_tree_head_v1_set_n_items(signed_tree_head_v1_t *inp, uint64_t val);
/** Return the length of the dynamic array holding the signatures
 * field of the signed_tree_head_v1_t in 'inp'.
 */
size_t signed_tree_head_v1_getlen_signatures(const signed_tree_head_v1_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * signatures of the signed_tree_head_v1_t in 'inp'.
 */
struct sigident_ed25519_st * signed_tree_head_v1_get_signatures(signed_tree_head_v1_t *inp, size_t idx);
/** As signed_tree_head_v1_get_signatures, but take and return a const
 * pointer
 */
 const struct sigident_ed25519_st * signed_tree_head_v1_getconst_signatures(const signed_tree_head_v1_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * signatures of the signed_tree_head_v1_t in 'inp', so that it will
 * hold the value 'elt'. Free the previous value, if any.
 */
int signed_tree_head_v1_set_signatures(signed_tree_head_v1_t *inp, size_t idx, struct sigident_ed25519_st * elt);
/** As signed_tree_head_v1_set_signatures, but does not free the
 * previous value.
 */
int signed_tree_head_v1_set0_signatures(signed_tree_head_v1_t *inp, size_t idx, struct sigident_ed25519_st * elt);
/** Append a new element 'elt' to the dynamic array field signatures
 * of the signed_tree_head_v1_t in 'inp'.
 */
int signed_tree_head_v1_add_signatures(signed_tree_head_v1_t *inp, struct sigident_ed25519_st * elt);
/** Return a pointer to the variable-length array field signatures of
 * 'inp'.
 */
struct sigident_ed25519_st * * signed_tree_head_v1_getarray_signatures(signed_tree_head_v1_t *inp);
/** As signed_tree_head_v1_get_signatures, but take and return a const
 * pointer
 */
const struct sigident_ed25519_st *  const  * signed_tree_head_v1_getconstarray_signatures(const signed_tree_head_v1_t *inp);
/** Change the length of the variable-length array field signatures of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int signed_tree_head_v1_setlen_signatures(signed_tree_head_v1_t *inp, size_t newlen);


#endif
